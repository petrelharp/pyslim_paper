// -------------------
// WITHIN-HOST MODEL
// -------------------

// INITIALIZE
initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(keepPedigrees = T);
	initializeTreeSeq();
	defaults = Dictionary(
		"SEED", getSeed(),
		"HOST_ID", "00",               // this host ID
		"INFILE", "",                  // optional file to start from
		"TRANSMISSION_DAYS", integer(0), // a list of which day does transmission happen relative to start
		"OUTPUT_HOST_IDS", integer(0), // a list of IDs of hosts to output infections for
		"SAMPLING_DAY", 60,            // final sampling day relative to start
		"NUM_SAMPLES",  10,            // number of samples
		"N_FOUNDERS", 20,              // number chosen to start a new infection
		"POP_GROWTH_RATE", 1.0,        // rate of growth of population
		"K", 1e5     				       // carrying capacity within host
		);
	
	// Set up parameters with a user-defined function
	setupParams(defaults);
	defineConstant("PARAMS", defaults);

	initializeChromosome(1, 1, "H");
	initializeRecombinationRate(0);
	initializeMutationRate(0);
	initializeMutationType("m0", 0, "f", 0);
	initializeGenomicElementType("g1", m0, 1);
	initializeGenomicElement(g1, 0, 0);

	// stop if number of output host ids is not the same as the number of transmission events
	if (length(TRANSMISSION_DAYS) != length(OUTPUT_HOST_IDS)) {
		stop("Number of output host ids does not equal the number of transmission days");
	}

	// print start message
	catn("\n\nWITHIN-HOST PARAMETER SUMMARY:\n");
}

// Pathogens infect host
1 late() {
   // start seed simulation or load an input file
	pop_id = asInteger(HOST_ID);
   if (INFILE == "") {
      catn("\nSTARTING SEED SIMULATION\n");
      sim.addSubpop(pop_id, N_FOUNDERS);
      PARAMS.setValue("FOUNDERS", Dictionary(HOST_ID, c()));
      PARAMS.setValue("FOUNDING_TIME", Dictionary(HOST_ID, sim.cycle));
   } else {
      catn("\nSTARTING SIMULATION FROM " + INFILE + "\n");
      sim.readFromPopulationFile(INFILE);
      // load metadata, which stores information about which individuals are needed to seed this infection
      metadata = treeSeqMetadata(INFILE);
      // determine which individuals to keep
      founder_ids = metadata.getValue("FOUNDERS").getValue(HOST_ID);
      PARAMS.setValue("FOUNDERS", metadata.getValue("FOUNDERS"));
      PARAMS.setValue("FOUNDING_TIME", metadata.getValue("FOUNDING_TIME"));
      // transfer founders to a new population and kill everyone else
      active_pop = sim.addSubpop(pop_id, 0);
      founders = sim.individualsWithPedigreeIDs(founder_ids);
      active_pop.takeMigrants(founders);
      if (size(founders) != size(founder_ids)) {
         catn("Desired founders: " + paste(founder_ids, sep=","));
         catn("Obtained founders: " + paste(active_pop.individuals.pedigreeID, sep=","));
      	stop("Some founding individuals are not present (or alive)!");
      }
   }
   // track simulation start day
   defineConstant("SIM_START", sim.cycle);		
   PARAMS.setValue("SIM_START", SIM_START);
   // calculate the overall transmission day
   defineConstant("ABS_TRANSMISSION_DAYS", SIM_START + asInteger(TRANSMISSION_DAYS));
   PARAMS.setValue("ABS_TRANSMISSION_DAYS", ABS_TRANSMISSION_DAYS);
   defineConstant("ABS_SAMPLING_DAY", SIM_START + asInteger(SAMPLING_DAY));
   PARAMS.setValue("ABS_SAMPLING_DAY", ABS_SAMPLING_DAY);
}

// Pathogens are transmitted to next host
unique(ABS_TRANSMISSION_DAYS) late() {
	// parse 'output_host_id' to figure out which hosts to transmit to
	which_hosts = which(ABS_TRANSMISSION_DAYS == community.tick);
	hosts_to_infect = OUTPUT_HOST_IDS[which_hosts];
	// determine how many pathogens are needed to infect all hosts
	N_pathogens = rep(N_FOUNDERS, count = length(hosts_to_infect));
	// sample individuals to transmit
	transmitted_inds = sample(sim.subpopulations.individuals, size = sum(N_pathogens), replace = F);
	sim.treeSeqRememberIndividuals(transmitted_inds); // permanently remember these individuals in subsequent parallel infection steps
	// construct dictionary of infected hosts and viral genomes to be transmitted to each
	founders = PARAMS.getValue("FOUNDERS");
	founding_time = PARAMS.getValue("FOUNDING_TIME");
	for (host in hosts_to_infect, count in N_pathogens, range_end in cumSum(N_pathogens)) {
		sampled_inds = transmitted_inds[(range_end-count):(range_end-1)];
		founders.setValue(host, sampled_inds.pedigreeID);
		founding_time.setValue(host, sim.cycle);
	}
	sim.killIndividuals(transmitted_inds);
}

ABS_SAMPLING_DAY late() {
	// also remember some non-transmitted individuals
	sim.treeSeqRememberIndividuals(sim.subpopulations.sampleIndividuals(rpois(1, NUM_SAMPLES)));
}

max(c(ABS_TRANSMISSION_DAYS, ABS_SAMPLING_DAY)) late() {
	// write out a tree sequence containing the information needed for all subsequent infections
	sim.killIndividuals(sim.subpopulations.individuals);
	sim.treeSeqOutput("sim_" + HOST_ID + ".trees", metadata=PARAMS);
	sim.simulationFinished();
}

// Pathogens replicate within the host
reproduction() {
	active_pop = sim.subpopulations[sim.subpopulations.id == asInteger(HOST_ID)];
	// choose the target population size based on the specified population growth rate
	num_offspring = rpois(n = active_pop.individualCount, lambda = POP_GROWTH_RATE);
	for (i in active_pop.individuals, n in num_offspring) {
		offspring = active_pop.addCloned(i, count=n);
	}
	self.active = 0;
}

// Individuals have their fitness scaled according to the overall population size (logistic growth)
2: early() {
	sim.subpopulations.fitnessScaling = pmin(0.9, K / sim.subpopulations.individualCount);
}


function (void)setupParams(object<Dictionary>$ defaults)
{
	for (k in defaults.allKeys) {
		if (!exists(k))
			defineConstant(k, defaults.getValue(k));
		else
			defaults.setValue(k, executeLambda(k + ";"));
	}
	catn("===========================");
	catn("Model constants: " + defaults.serialize("pretty"));
	catn("===========================");
}
