// -------------------
// WITHIN-HOST MODEL
// -------------------

// INITIALIZE
initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(keepPedigrees = T);
	initializeTreeSeq();
	defaults = Dictionary(
		"SEED", getSeed(),
		"HOST_ID", "00",               // this host ID
		"INFILE", "",                  // optional file to start from
		"ABS_TRANSMISSION_DAYS", integer(0), // a list of which day does transmission happen
		"OUTPUT_HOST_IDS", integer(0), // a list of IDs of hosts to output infections for
		"ABS_SAMPLING_DAY", 60,            // final sampling day
		"NUM_SAMPLES",  10,            // number of samples
		"N_FOUNDERS", 20,              // number chosen to start a new infection
		"POP_GROWTH_RATE", 1.0,        // rate of growth of population
		"K", 1e5     				       // carrying capacity within host
		);
	
	// Set up parameters with a user-defined function
	setupParams(defaults);
	defineConstant("PARAMS", defaults);

	initializeChromosome(1, 1, "H");
	initializeRecombinationRate(0);
	initializeMutationRate(0);
	initializeMutationType("m0", 0, "f", 0);
	initializeGenomicElementType("g1", m0, 1);
	initializeGenomicElement(g1, 0, 0);

	// stop if number of output host ids is not the same as the number of transmission events
	if (length(ABS_TRANSMISSION_DAYS) != length(OUTPUT_HOST_IDS)) {
		stop("Number of output host ids does not equal the number of transmission days");
	}

	// print start message
	catn("\n\nWITHIN-HOST PARAMETER SUMMARY:\n");
}

// Pathogens infect host
1 late() {
   // start seed simulation or load an input file
	pop_id = asInteger(HOST_ID);
   if (INFILE == "") {
      catn("\nSTARTING SEED SIMULATION\n");
      sim.addSubpop(pop_id, N_FOUNDERS);
      PARAMS.setValue("FOUNDING_TIME", Dictionary(HOST_ID, sim.cycle));
   } else {
      catn("\nSTARTING SIMULATION FROM " + INFILE + "\n");
      sim.readFromPopulationFile(INFILE);
      // pass on information kept in metadata
      metadata = treeSeqMetadata(INFILE);
      PARAMS.setValue("FOUNDING_TIME", metadata.getValue("FOUNDING_TIME"));
      // check we've got the individuals alive that we want
      if (any(sim.subpopulations.individuals.subpopulation.id != asInteger(HOST_ID))) {
      	catn("All individuals should be from subpop " + asInteger(HOST_ID));
      	for (pop in sim.subpopulations) {
      		catn("Subpop " + pop.id + " has " + pop.individualCount);
      	}
      	stop("This is not good.");
      }
   }
   // track simulation start day
   defineConstant("SIM_START", sim.cycle);		
   PARAMS.setValue("SIM_START", SIM_START);
}

// Pathogens are transmitted to next host
unique(ABS_TRANSMISSION_DAYS) late() {
	// parse 'output_host_id' to figure out which hosts to transmit to
	which_hosts = which(ABS_TRANSMISSION_DAYS == community.tick);
	hosts_to_infect = OUTPUT_HOST_IDS[which_hosts];
	// determine how many pathogens are needed to infect all hosts
	N_pathogens = rep(N_FOUNDERS, count = length(hosts_to_infect));
	// sample individuals to transmit
	active_pop = sim.subpopulations[sim.subpopulations.id == asInteger(HOST_ID)];
	transmitted_inds = active_pop.sampleIndividuals(size=sum(N_pathogens), replace=F);
	// construct dictionary of infected hosts and viral genomes to be transmitted to each
	founding_time = PARAMS.getValue("FOUNDING_TIME");
	for (host in hosts_to_infect, count in N_pathogens, range_end in cumSum(N_pathogens)) {
		sampled_inds = transmitted_inds[(range_end-count):(range_end-1)];
		founding_time.setValue(host, sim.cycle);
      // transfer founders to a new population
      new_pop = sim.addSubpop(asInteger(host), 0);
      new_pop.takeMigrants(sampled_inds);
	}
	// permanently remember these individuals through subsequent tree sequences;
 	// this must happen after they are moved to the new population above
	sim.treeSeqRememberIndividuals(transmitted_inds);
	sim.killIndividuals(transmitted_inds);
}

ABS_SAMPLING_DAY late() {
	// also remember some non-transmitted individuals
	sim.treeSeqRememberIndividuals(sim.subpopulations.sampleIndividuals(rpois(1, NUM_SAMPLES)));
}

max(c(ABS_TRANSMISSION_DAYS, ABS_SAMPLING_DAY)) late() {
	// write out a tree sequence containing the information needed for all subsequent infections
	sim.killIndividuals(sim.subpopulations.individuals);
	sim.treeSeqOutput("sim_" + HOST_ID + ".trees", metadata=PARAMS);
	sim.simulationFinished();
}

// Pathogens replicate within the host
reproduction() {
	active_pop = sim.subpopulations[sim.subpopulations.id == asInteger(HOST_ID)];
	// choose the target population size based on the specified population growth rate
	num_offspring = rpois(n = active_pop.individualCount, lambda = POP_GROWTH_RATE);
	for (i in active_pop.individuals, n in num_offspring) {
		offspring = active_pop.addCloned(i, count=n);
	}
	self.active = 0;
}

// Individuals have their fitness scaled according to the overall population size (logistic growth)
2: early() {
	sim.subpopulations.fitnessScaling = pmin(0.9, K / sim.subpopulations.individualCount);
}


function (void)setupParams(object<Dictionary>$ defaults)
{
	for (k in defaults.allKeys) {
		if (!exists(k))
			defineConstant(k, defaults.getValue(k));
		else
			defaults.setValue(k, executeLambda(k + ";"));
	}
	catn("===========================");
	catn("Model constants: " + defaults.serialize("pretty"));
	catn("===========================");
}
