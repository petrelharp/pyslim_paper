\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lineno}
\usepackage{authblk}
\usepackage[margin=1in]{geometry}
\usepackage{xparse}
\usepackage{xpunctuate}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[hidelinks]{hyperref}
\usepackage[all]{hypcap}
\usepackage{amsmath}
\usepackage{cleveref}
\usepackage{placeins}
\usepackage{flafter}
\usepackage{floatrow}
% \usepackage{float}
\usepackage{subcaption}
\usepackage{minted} 
\setminted[python]{breaklines}
\usepackage{caption}
\usepackage{csvsimple}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage[numbers,round,sort]{natbib}

%% annoying stuff for publication
\usepackage{setspace}
\doublespacing
\usepackage[figuresonly,nolists,nomarkers]{endfloat}

% local definitions
\newcommand{\msprime}[0]{\texttt{msprime}\xspace}
\newcommand{\tskit}[0]{\texttt{tskit}\xspace}
\newcommand{\slim}[0]{\texttt{SLiM}\xspace}
\newcommand{\pyslim}[0]{\texttt{pyslim}\xspace}
\newcommand{\stdpopsim}[0]{\texttt{stdpopsim}\xspace}
\newcommand{\allel}[0]{\texttt{scikit-allel}\xspace}
\newcommand*{\eg}{e.g.\xcomma}
\newcommand*{\ie}{i.e.\xcomma}
\newcommand{\comment}[1]{\textit{\color{green} #1}}
\newcommand{\p}[1]{\texttt{p#1}}

% syntax highlighting
\input{slim_highlighting.tex}
\definecolor{bg}{rgb}{0.95,0.95,0.98}
\newminted[pycon]{pycon}{bgcolor=bg, linenos=true, tabsize=4}

\linenumbers

\begin{document}

\title{Bridging forward-in-time and coalescent simulations using pyslim}
\author[1,$\dagger$]{Shyamalika Gopalan}
\author[2,3,$\dagger$]{Murillo F. Rodrigues}
\author[3,4]{Peter L. Ralph}  % 0000-0002-9459-6866
\author[5]{Benjamin C. Haller}

\affil[1]{Department of Genetics and Biochemistry and Center for Human Genetics, Clemson University}
\affil[2]{Division of Genetics, Oregon National Primate Center, Oregon Health \& Science University}
\affil[3]{Department of Biology and Institute of Ecology and Evolution, University of Oregon}
\affil[4]{Department of Mathematics, University of Oregon}
\affil[5]{Department of Computational Biology, Cornell University}
\affil[$\dagger$]{These authors contributed equally.}

\maketitle

\abstract{
    Ancestral Recombination Graphs (ARGs)
    provide an expressive and compact way to represent genetic variation data generated by simulations
    embedded within its genealogical history,
    and it can dramatically speed up simulations.
    The fact that the ARG records genealogical as well as genomic information
    opens up the possibility for a number of new analysis and simulation techniques.
    Here, we aim to introduce the reader to this deep source of information
    as produced by the forwards simulator \slim.
    \slim records the ARG using the \emph{tree sequence} format,
    which can be manipulated using the \tskit and \pyslim python packages.
    We first describe the information that \slim records in the tree sequence,
    then provide several examples that use the tree sequence as a format
    to losslessly pass population states between simulators:
    \emph{recapitation} of a forwards simulation with coalescent simulation;
    initiation of a forwards simulation using the results of a coalescent simulation;
    and parallelization of simulations, first across branches of a phylogenetic tree,
    and then across the populations of parasites infecting different hosts.
}
\date{}


\section{Introduction}
% The importance of simulations in popgen and flavors of simulations
Simulations have become an invaluable tool in population genetics over the past six decades,
allowing researchers to model increasingly complex evolutionary scenarios.
%because of the difficulty in obtaining analytical solutions to complex evolutionary scenarios.
A robust research community has grown around developing computational methods for conducting these
simulations, as well as for representing and analyzing the data that they produce.
% Indeed, in prior chapters, two of the most widely used population genetic simulation tools were presented:
% \slim \citep{haller_slim_2023} and \msprime \citep{baumdicker_efficient_2022}.
% refer to other chapters here?

In this chapter, we present a practical introduction to \pyslim, a Python package that facilitates \emph{hybrid simulations}
using \slim and \msprime.
Hybrid simulations are frequently used to combine key features of the two main methods of individual-based population genetic simulation.
These two methods differ primarily in the direction of the simulation
process -- either forward- or backward-in-time. 
The coalescent process models the ancestry of sampled genomes
backward-in-time until they coalesce into their most common recent ancestor. % (MRCA).
This approach is extremely efficient because it only simulates the ancestors that directly contributed to the sampled genomes,
thus avoiding the need to represent large swathes of the population pedigree. 
The downside of this approach is its strict assumptions (\eg neutrality, random mating within subpopulations), 
which limit applicability.
On the other hand, forward-in-time simulations apply demographic processes
such as reproduction, migration and mutation
beginning with a set of ancestral individuals representing the entire population.
This affords forward-in-time simulations much more flexibility,
but at a higher computational cost.
% refer to msprime and SLiM chapters explicitly here?
% The pyslim package and overview of the chapter

Hybrid simulations have recently emerged as a strategy for leveraging the benefits of both forward-in-time and coalescent methods, as well as parallel computing,
to efficiently model highly complex evolutionary scenarios.
Many forward-in-time simulations conducted using \slim, for example, are later modified using the coalescent process to ensure the coalescence of the individuals in the first generation, a process known as \emph{recapitation} \citep{kelleher_efficient_2018}, which will be discussed in more detail later in this chapter.
% For instance, this is done by \stdpopsim, a Python package that stores a large number of published population genetic models
% \citep{adrion_community-maintained_2020,lauterbur2023expanding,gower_accessible_2025}.
Since recapitation provides the genetic diversity of the initial generation
it can be particularly helpful in expensive simulations --
for instance,
in the spatial simulations of \citet{battey_space_2020} and \citet{petr_slendr_2023}.
As described later in this chapter,
\citet{rodrigues_shared_2024} performed whole-chromosome simulations of 10 million years of the entire great apes history,
which would not have been possible without hybrid simulation techniques.
%% NOT citing this because they recommend doing burn-in with CheckCoalescent
% For a recent review (and benchmarking) of these approaches,
% see \citet{johnson2024population}.

% something here to motivate the pathogen evolution scenario we present?

Hybrid simulations would not be possible without Ancestral Recombination Graphs (ARGs), 
a general class of data structures reviewed in \citet{wong_general_2024}.
Compared to genotypes,
the ARG represents a much richer source of information about the processes that gave rise to a given set of genomes.
There are different formats for working with ARGs \citep{palamara2016argon,dehaas2024enabling,parida2011minimal,gunnarsson2024scalable};
here, we use the \emph{tree sequence} data structure \citep{kelleher_efficient_2016,ralph_efficiently_2020}
that is used by \msprime and \slim via the C and python libraries provided by \tskit.

Here, we will review how \slim, a popular forward-in-time simulation software, uses the tree sequence before describing
the main uses of \pyslim in conducting hybrid simulations, specifically:
(i) recapitation, the process of simulating the history of uncoalesced first-generation individuals,
(ii) generation of initial diversity using the coalescent process for forward-in-time simulations with selection,
(iii) parallelization of multi-population simulations.
Finally, to illustrate the realism that can be achieved with a hybrid approach, we present a vignette of an organism evolving under a complex life history.
For introductions on using \msprime and \slim,
see Chapters 14 and 15 of this volume.
For further details on these examples,
refer to the \pyslim{} documentation (\url{https://tskit.dev/pyslim/docs/latest}),
from which some of the text presented here was adapted.
The code used in this paper is available in the accompanying git repository at
\url{https://github.com/StatisticalPopulationGenomics-2ndEd/pyslim/}.

%%%%%%%%%%%%%%%%%%%%%
\section{Tree sequences and \slim}
An ``ancestral recombination graph'' (ARG)
represents paths of genealogical inheritance and mutation that have produced a given set of genomes,
and the \emph{tree sequence} format of \tskit provides a general-purpose way to store ARGs.
See \cite{lewanski2024introduction} and \citet{brandt2022evaluation} for reviews of the applications of ARGs
and \citet{wong_general_2024} for an overview of the terminology and history of ARGs as we use it here.
For this reason, we mostly use the term ``tree sequence'' in this chapter even where ``ARG'
would be equally accurate, as well as other terminology associated with \slim and \tskit \citep{kelleher_efficient_2016,ralph_efficiently_2020,wong_general_2024}.
Other simulators also produce tree sequences,
but we have not tested those with \pyslim, and so do not discuss them here.

As \slim proceeds with simulating genomes evolving forward-in-time, 
if ``tree sequence recording'' is enabled,
it tracks how all the genomes are
related to each other and returns the result as an ARG in tree sequence format. First, we describe
\emph{what} information is recorded, \emph{how} it is recorded, and how to access it.

\paragraph{Terminology:}
Each \textit{node} of a tree sequence represents a single (haploid) genome;
inheritance relationships between these are recorded as \textit{edges},
and genetic variation is represented by \textit{mutations} at associated \textit{sites}.
A particular tree sequence describes the entire genealogy of a set of ``focal'' nodes called
\textit{sample nodes}, or simply \textit{samples}, over the simulated time period.
Many \tskit operations act on these sample nodes by default.
The samples are those genomes for which we have complete genetic ancestry information; 
we likely only have partial information about the other 'non-sample' nodes in the tree sequence,
which are included because they are required to describe that ancestry.
(``Who is and isn't in the tree sequence'' below gives more detail about sample nodes.)
By default, \slim simulates diploid organisms, where each \textit{individual}'s genome is represented by two nodes.

Since \slim is a forwards simulator, it records time (in units called ``ticks'')
since the start of the simulation, with 0 corresponding to the earliest time point.
We call this \textit{\slim time}.
However, in many cases, a more natural point of reference might be in relation to the samples
(which are after all probably ``sampled'' today),
and so time in the tree sequence is measured in units of \textit{time ago}.
This is the same way that time
is represented in coalescent or backward-in-time approaches, with a time of 0 corresponding
to the end of the simulation rather than the beginning.
This dual representation of time is important
to keep in mind when thinking about hybrid simulations, as we will see later in the chapter.

\begin{figure}
\centering
    \subcaptionbox{All relationships.}{\vspace{0em}\includegraphics[width=0.3\textwidth]{figures/pedigree0.pdf}\hspace{0em}} % MFR: I added these spaces because for some weird reason Inkscape keeps crashing when I try to edit the original svgs
    \hfill
    \subcaptionbox{Those relationships left at the end of the simulation.}{\includegraphics[width=0.3\textwidth]{figures/pedigree2.pdf}}
    \hfill
    \subcaptionbox{Additional individuals may be ``remembered'' (purple)
        or ``retained'' (dotted).}{\includegraphics[width=0.3\textwidth]{figures/pedigree_remember.pdf}}
\caption{
    The resulting genetic relationships between individuals in a small simulation
    (three diploids over five generations).
}
\label{fig:indivs}
\end{figure}

\paragraph{Who is and isn't in the tree sequence:}
Suppose we have run a very small simulation with \slim. The genetic relationships among each of the
diploid individuals who were alive over the course of the simulation might
look something like Figure~\ref{fig:indivs}A. Since individuals (circles) are diploid, each contains
two genomes or nodes (shaded rectangles).
The edges of the tree sequence record which specific parts of the genome are inherited,
so the relationships recorded in the edges of a tree sequence are between the nodes and not the individuals directly.

By default, the sample nodes are simply the genomes of the individuals that are alive in the final generation
of the simulation. This renders large portions of these relationships unnecessary for representing the samples' history,
as they correspond to lineages that died out at some earlier point in the simulation.
% (but see section below on ``Historical Individuals'' about how to record ancient samples).
To avoid having to
store this large quantity of unnecessary information, \slim periodically \textit{simplifies} the tree sequence
as the simulation goes along. By default, simplification will only keep the portions of the
genetic genealogy that are required to represent the history of the current nodes \citep{kelleher_efficient_2018}.
Additionally, it defaults to removing any node that is not a genetic
\textit{most recent common ancestor} (MRCA) of at least two daughter nodes. This removes historical
nodes that are only ``on the line to'' a sample, but do not represent a branching point
(\ie coalescent event) on the genealogical tree at some point on the genome.
% (These 'unary nodes' can be retained within \slim in certain cases,
% as we discuss below.)
Below, we discuss how to retain additional historical information.

As a result of the simplification process, the output tree sequence will look something like Figure~\ref{fig:indivs}B.
To be precise, edges correspond to inherited genomic \emph{segments} with defined start and end positions,
but we do not attempt to depict that complexity here.
% PLR: this is not true because nodes have more than one ancestor
% Instead, this figure can be thought of as representing a simulation
% with no recombination, so entire nodes, rather than genomic segments, are being inherited.

Individuals who are alive at the end of the simulation automatically have their nodes marked as \textit{samples}.
\emph{No} other individuals (depicted as circles) are present,
although some of their nodes remain.
In \slim, certain information (including spatial location and age) is associated with individuals,
not nodes, so by default we do not have access to this information for historical individuals.
\tskit also allows individuals to have a ``parents'' property that \slim makes use of,
so parentage information is also available even if no genetic material has been transmitted,
but only if both parent and child individuals are represented in the tree sequence.

%%%%%%%% %%%%%%%%%%%%%%
\section{Historical individuals}
By default, only the nodes associated with individuals alive in the final generation are part of the set of samples.
However, there are many cases where we might want to retain the complete ancestry, and other metadata, for
historical individuals.
For example, we might want to model the relationship between a modern population and
one particular individual from the past.
Or, as below, if we are conducting simulations in parallel that share 
a common ancestry, we may need to retain certain nodes that are critical for linking distinct
tree sequences back together.
In order to accomplish this, we can choose to ``remember'' key individuals during the course of the simulation,
using the \slim function \verb|treeSeqRememberIndividuals()|.

\paragraph{Permanently remembering individuals}
By default, a call to \\ 
\verb|treeSeqRememberIndividuals()| will permanently remember one or more individuals,
the simulated equivalent of ancient DNA dug out of permafrost.
This means that any tree sequence subsequently output will always contain this individual,
its nodes (now marked as samples), and its full ancestry.
The result of remembering an individual in the introductory example is pictured
in Figure~\ref{fig:indivs}C.
This is also useful to, for instance, access allele frequencies and spatial locations of individuals
at a particular time in the past.
As an extreme case, all individuals at all time points can be remembered,
thus retaining the complete population pedigree of everyone ever alive,
but this quickly becomes computationally burdensome.

\paragraph{Retaining individuals}
Alternatively, you may want to only retain historical individuals as long as their nodes are still
relevant to reconstructing the genetic ancestry of the sample nodes.
The ancestral nodes that \slim includes in the tree sequence do not by default have their associated individuals included as well,
and so at the end of the simulation we do not by default have access to individual-level information for non-sample nodes
such as spatial location or parental IDs.
But, we can ask \slim to also record historical individuals (and hence their associated information)
as long as their nodes are retained through simplification.
You can \emph{retain} individuals in this way by using
\verb|treeSeqRememberIndividuals(..., permanent=F)|.
This is less burdensome than permanently remembering them because individuals can still be removed by simplification
once their nodes (which are not marked as samples) are no longer ancestral to the samples.
Since a retained individual's nodes are not samples,
they are subject to the standard removal `rules' of simplification.
It is therefore possible to end up with an individual containing only one genome, as shown in the diagram.
However, as soon as both nodes of a retained individual have been lost,
the individual and any information associated with it is deleted as well.

As previously discussed, simplification will, by default, only keep nodes if they are a coalescent point
(\ie they are a MRCA or branch point) somewhere along the genome.
This can be changed by initialising tree sequence recording in \slim using
\verb|treeSeqInitialize(retainCoalescentOnly=F)|.
\slim will then preserve all retained individuals while they remain in the genealogy of present-day individuals,
even if their nodes are not coalescent points in the tree.
If you later decide to reduce the number
of samples in the tree sequence, you can do so using the tskit function \verb|simplify()|
(which is what \slim uses under the hood).
In this case, individuals that are ``retained'' rather than ``remembered'' will be kept only
if they are still MRCAs in the ancestry of the selected samples.
This behavior corresponds to the
\verb|keep_unary_in_individuals| argument to \verb|tskit.simplify|.

%%%%%%%%%%%%%%%%%%%%%%%
\section{Recapitation: tying up loose ends} %% "Streamlining the burn-in, two ways"

\begin{figure}
\centering
    \includegraphics[width=0.2\textwidth]{figures/pedigree_recapitate.pdf}
    % \includegraphics[width=0.2\textwidth]{figures/pedigree_simplify.pdf}
\caption{
    % \textbf{(A)}
    Recapitation adds the green nodes 
    to the simulation of Figure~\ref{fig:indivs} by coalescent simulation.
    % \textbf{(B)} The result of \emph{simplifying} the tree sequence in (A)
    % down to the four sample nodes shown.
}
\label{fig:recap_simp}
\end{figure}

By default, a \slim simulation begins with all individuals being identical, and genetic diversity
builds up over time as new mutations occur. However, in many cases, starting with a clonal population
is undesirable and can have long-lasting effects on patterns of diversity in the samples. One way to overcome
this is to include a long ``burn-in'' period in the forward simulation to reach an equilibrium level of genetic diversity.
However, this period generally needs to be quite long (on the order of 5--15 times the effective population size, in generations),
which can be prohibitive.
An efficient alternative is to ``seed'' the simulation with genetic diversity generated by a coalescent simulation, \ie conduct a hybrid simulation.
There are two main ways to do this, which we refer to as ``recapitation'' and ``generating initial diversity'', respectively.
Both ways should be thought of as generating initial diversity, but recapitation (counterintuitively) generates that diversity after the fact.
So, the main difference between them is when
this coalescent step is run relative to the forward-in-time portion of the simulation.
We will discuss these approaches in the following two sections.

Recapitation is done with a tree sequence generated by \slim simulation.
This is suitable if the \slim step does not require the ancestral genotypes for anything, such as determining individual fitness,
so all we want to know is how the demographics of the \slim simulation affects initially present neutral variation.
Functionally, recapitation conducts a coalescent simulation
starting with those portions of the first-generation ancestral nodes (\slim time 0) that have not yet coalesced.
This is discussed in more detail in \citet{haller_tree-sequence_2019}.

Figure~\ref{fig:recap_simp} illustrates this process: imagine that, at some sites, one or more samples do not share
a common ancestor within the \slim simulated portion of history (shown in blue).
Recapitation starts at the \textit{top} of the genealogies and moves backwards in time
to fill in a genealogical history for all the samples.
The green chromosomes here are new ancestral nodes that have been added to the tree sequence.
As previously mentioned, the effect of omitting this step would be a genetically homogeneous initial population;
our simulation would have less genetic variation than it ``should'' have, since all the variation
contributed by the green portion of the tree would be omitted.

% % PLR: I don't think we need this?
% It is important to consider how time is conceptualized in this hybrid simulation. In forward simulation (\ie \slim) time,
% the first-generation ancestors at the top of the blue portion of the genealogy are ``born'' at time 0. When we recapitate the genealogy,
% nodes in the green portion of the genealogy will necessarily be born in negative \slim time since they arise before the events of the
% forward-in-time portion of the simulation. In coalescent time, the age of the recapitated nodes simply increases relative to the final generation
% (\ie the set of nodes at the \textit{bottom} of the blue genealogy). %% could be explained more clearly, i think (SSG)

Recapitation within a single randomly-mating population of a size \verb|N|
can be achieved with a simple call to \verb|pyslim.recapitate(ts, ancestral_size=N)|
Since \verb|recapitate| is a wrapper around
\verb|msprime.sim_ancestry|, we could recapitate our tree with any model that can be represented by \msprime code \citep{baumdicker_efficient_2022}.
For instance, it is possible to recapitate a \slim-generated tree sequence with a fluctuating population size
or non-uniform genetic map by simply passing in the relevant arguments.

Setting up a demographic model in \msprime that is consistent and compatible with a particular \slim simulation requires
understanding some of the finer details of each of these software packages, so here we will present a concrete example.
Suppose our \slim model has the following population structure:
\begin{lstlisting}[language=slim, style=slimstyle, breaklines=true]
1 early() {
   sim.addSubpop("p1", K);
   sim.addSubpop("p2", K);
}
\end{lstlisting}
for some population size \verb|K|.
If the resulting tree sequence is stored in the file \texttt{recap\_example.trees},
then examining the populations using the shell, we see
(edited to remove some extraneous information):
% % what it actually looks like:
% \begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{bash}
% > tskit populations recap_example.trees
% id	metadata
% 0	None
% 1	{'migration_records': [], 'name': 'p1', 'sex_ratio': 0.0, 'slim_id': 1}
% 2	{'migration_records': [], 'name': 'p2', 'sex_ratio': 0.0, 'slim_id': 2}
% \end{minted}
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{bash}
> tskit populations recap_example.trees
id	metadata
0	None
1	{'name': 'p1', 'slim_id': 1}
2	{'name': 'p2', 'slim_id': 2}
\end{minted}
(We could see this in python by \verb|print|ing the relevant population objects.)
There are \emph{three} populations, but the first one is unused (and has no metadata),
because \slim stores population \texttt{pX} as population \texttt{X},
and our \slim script had subpopulations \verb|p1| and \verb|p2|.
To be compatible with this tree sequence, the \msprime demographic model will need to include three populations as well.
However the first population will remain unused unless we specify it as an ancestral source for
one of the other two populations during the coalescent phase of the simulation.
% Note that we could have avoided having this
% `dummy' population if we had named our two populations `p0' and `p1' within the \slim script. Similarly, if we would have started
% numbering our populations from `p3', we would end up with a total of three `dummy' populations in our tree sequence.

Regardless of the population numbering scheme used, \msprime provides a built-in method of seamlessly generating a
compatible demography given a particular starting tree sequence file. The following code uses the information in the tree sequence \verb|ts|
to create a basic compatible demography:
%% read recap_example.trees as ts?
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
ts = tskit.load("recap_example.trees")
demography = msprime.Demography.from_tree_sequence(ts, initial_size=100)
\end{minted}
The resulting demography has 3 populations with an effective size of 100 individuals each.
Note that the \verb|initial_size|
does not have to match what we specified in our \slim simulation, because it specifies the size of the generation
immediately preceding the \slim phase. We could theoretically try to recapitate our tree sequence with this
demography, but if we did so, \msprime would run forever. This is because we have not allowed for any way for
lineages from population \p1 to coalesce with lineages in population \p2, or vice versa.
Therefore, the coalescent process will never be able to conclude.

To remedy this,
% we need to provide a migration path that allows lineages from different populations to coalesce.
let us specify one-directional migration from \p1 to \p2 (so, lineages in \p2 move into \p1 as we move backwards in time)
starting 100 generations before the start of the \slim simulation.
The current time (``tick'') in \slim is stored in the tree sequence's top-level metadata, as \verb|ts.metadata['SLiM']['tick']|,
which we can use to identify when the desired time point is
(and note that this must be specified in tskit time, \ie as ``time ago'').
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
demography.add_migration_rate_change(
    time=ts.metadata["SLiM"]["tick"] + 100,
    rate=0.1, source="p2", dest="p1")
rts = pyslim.recapitate(ts, demography=demography,
            recombination_rate=1e-8)
\end{minted}

The \pyslim function `recapitate' passes the tree sequence \verb|ts| to the
\verb|initial_state| argument of \verb|msprime.sim_ancestry|,
along with the demographic model that we specified.
The root of each uncoalesced lineage in this tree sequence is a node
that exists at a particular time and in a particular population;
these two things situate the lineage within the demographic model,
allowing \msprime to continue following the lineages back through time.

At this point we need to raise an important caveat:
in non-Wright-Fisher models in \slim,
time units are likely not in units of generations.
This means that \emph{different} mutation and recombination rates need to be passed to \msprime,
because these rates in \slim are ``per generation'' while for \msprime they are ``per unit time''.
For these and other considerations, see the \pyslim documentation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Generating initial diversity} % is there a better name for this process? this doesn`t have the same ring as 'recapitation'

If the \slim simulation needs to actually use the genotypes of the initial generation,
then we cannot recapitate.
Instead, we can run the coalescent simulation first to generate a starting tree sequence,
which is then loaded into \slim where the main simulation process can proceed as normal.
This approach is useful, for instance, when simulating selection on standing variation in a large population,
where a purely forward-in-time burn-in period would be very costly in terms of time and computational resources.
% Because the genetic variation needs to exist in the population at the start of the simulation, adding
% it on after the fact via recapitation, as discussed in the previous section, is not an option.
While running a neutral coalescent burn-in is not exactly the same as running a forward-in-time burn-in with selection,
this can be an adequate approximation (but caution is advised).

For instance,
imagine that we want to perform a lab experiment in which we take high-diversity
organisms from the wild and subject them to selection for a few dozen generations.
If we use the results of a coalescent simulation to represent our sample from the wild,
then we are effectively assuming that the genetic diversity in the wild population is (approximately) neutral.
This may not reflect reality: for instance,
alleles with larger effect on a trait under stabilizing selection might be expected to be at lower frequency.
For these reasons, we still suggest some burn-in in \slim,
although less is probably required, since you don't have to wait for diversity to be generated by mutation.
For our example, we will assume simply that the trait we are selecting for in the lab was
not under selection in the wild. To implement this, we will:
(1) run a coalescent simulation with \msprime;
(2) ``annotate'' the resulting tree sequence with \slim metadata, allowing it to be read into \slim;
(3) add \slim mutations with \msprime
        and edit the mutation metadata to assign selection coefficients; and finally
(4) run the \slim portion of the simulation.

\subsection{Annotating a tree sequence with \slim metadata}

Suppose we run the following coalescent simulation in \msprime:
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
  demog_model = msprime.Demography()
  demog_model.add_population(initial_size=1_000)
  ts = msprime.sim_ancestry(
          samples=1_000,
          demography=demog_model,
          random_seed=5,
          recombination_rate=1e-8,
          sequence_length = 90_000_000)
\end{minted}
This tree sequence \verb|ts| is a complete record of the genealogical information relating specific individuals
and nodes, but is missing other information that  \slim requires.
The other information needs to be added to metadata of various objects in the tree sequence,
and can be easily added using the \verb|annotate| function from \pyslim.
Although this function adds default values for most information,
we must provide the model type (Wright-Fisher or non-Wright-Fisher)
and some information about how coalescent- and \slim-time should be aligned.
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
ats = pyslim.annotate(ts, model_type="WF", tick=1, stage="late")
\end{minted}
When this tree sequence is loaded into \slim, the tick counter (\ie \slim time)
will be set to 1, and if it is not loaded in during the \verb|late()| stage a warning will be raised.

The function \verb|annotate()| fills in default values for every element of the tree sequence that is required by \slim,
which includes all individuals, all nodes that exist within living individuals, and all
populations referenced by nodes. We can see exactly what these defaults
are for any given component of the tree sequence by using \verb|default_slim_metadata|,
for instance:
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
pyslim.default_slim_metadata("individual")
# {'pedigree_id': -1, 'age': -1, 'subpopulation': -1, 'sex': -1,
#  'flags': 0, 'pedigree_p1': -1, 'pedigree_p2': -1}
\end{minted}
So, by default all individuals are hermaphroditic (individual \verb|sex| is -1)
and have \verb|age| equal to -1 (as appropriate for a WF simulation).
If we wanted, for instance, a sexual population we would then edit these values.
Below, we show how to edit the metadata of mutations; other modifications such as modifying individuals
can be done in a similar manner.

\subsection{Adding mutations with \slim metadata}

The simulation thus far had no mutations, so
the next step is to generate the initial genetic diversity that natural selection will act on
in the forward-in-time phase of our hybrid simulation. Let us assume an overall rate of $3 \times 10^{-8}$ new
mutations per base pair per generation. Further, let us assume that 99\% of all new mutations
are neutral, and the remaining 1\% have a selection coefficient of 0.001.
If we were doing this simulation entirely within a forward-in-time framework with a long
burn-in, we could have achieved this outcome using the following \slim code:
\begin{lstlisting}[language=slim, style=slimstyle, breaklines=true]
        initializeMutationType("m2", 0.5, "f", 0.001);
        initializeMutationRate(3e-10);
\end{lstlisting}
This code defines a mutation type \verb|m2| that has a dominance coefficient of 0.5 and a fixed selection
coefficient of 0.001 (the latter can be made more flexible, \eg drawn from a distribution -- see the \slim manual).
Notice, too, that we have set these non-neutral mutations to arise at a rate of $3 \times 10^{-10}$ per base per generation,
or 1\% of our desired overall mutation rate of $3 \times 10^{-8}$,
so we would add the remaining neutral mutations after the fact (as we do below here as well).
To approximate this result using \msprime, we must first
use the function \verb|msprime.sim_mutations|
with the \verb|SLiMMutationModel| to generate some mutations on the existing tree sequence:
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
mut_model = msprime.SLiMMutationModel(type=2)
mts = msprime.sim_mutations(ats, rate=3e-10, model=mut_model)
\end{minted}
The \verb|type=2| argument denotes that the mutations will be of type \verb|m2| in \slim, which will also
need to be explicitly initialized in the forward-in-time phase of the simulation (as in the \slim code above).
By default, these mutations are assigned a selection coefficient of 0, which is accurate since they
all arose in the neutrally-evolving portion of the tree. However, since we want selection to come into
effect for the \slim phase, we will need to update the selection coefficients of these variants.
Tree sequences are, for efficiency purposes, not directly modifiable. Therefore, to update any aspect of
a particular tree sequence we need to instead copy its underlying tables, modify them,
and then re-generate the tree sequence.
Doing this to change all selection coefficients to 0.001 looks like this:
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
tables = mts.dump_tables()
tables.mutations.clear()
for m in mts.mutations():
  md_list = m.metadata["mutation_list"]
  for md in md_list:
    md["selection_coeff"] = 0.001
    tables.mutations.append(
        m.replace(metadata={"mutation_list": md_list})
    )

sts = tables.tree_sequence()
\end{minted}
This code first copied all the tables that describe the tree sequence \verb|mts|, cleared all the
information in the mutations table, and then added each existing mutation from \verb|mts| back with a new selection
coefficient. Finally, it generated a new tree sequence from the resulting, modified, tables.
This tree sequence can now be read into \slim in order to proceed with the forward-in-time phase of our coalescent simulation.

Before we proceed to that step, however, we should take a detour through
some details about how mutations are represented in both \slim and \tskit. 
This is necessary to understand the above code (what is \verb|mutation_list|?),
and it has potentially confusing implications for hybrid simulations. 
In \tskit, each mutation has a ``derived state'', which is the allelic state that completely replaces any previous allelic state.
So, if a mutation occurs at a site where a mutation already exists,
the most recent mutation will replace the older one.
This differs from \slim, which, by default, allows recurrent mutations at the same genomic
position to `stack' on top of each other.
So, the \verb|SLiMMutationModel| encodes this ``stacking'' information within the \tskit mutation object.
Consider the following example of a `double hit' mutation
that could have been produced by the code above, produced by \verb|print(sts.mutation(295))|
(it is the $622^\text{th}$ mutation in \verb|sts|):
% Mutation(id=622, site=621, node=5607, derived_state='621,622', parent=621,
% metadata={'mutation_list': [{'mutation_type': 2, 'selection_coeff':
% 0.0010000000474974513, 'subpopulation': -1, 'slim_time': -987, 'nucleotide':
% -1}, {'mutation_type': 2, 'selection_coeff': 0.0, 'subpopulation': -1,
%  'slim_time': -8, 'nucleotide': -1}]}, time=9.684319995964623, edge=22712)
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
Mutation(id=622, site=621, node=5607, derived_state='621,622', parent=621, 
    metadata={'mutation_list': [
        {'mutation_type': 2, 'selection_coeff': 0.001, 'slim_time': -1691},
        {'mutation_type': 2, 'selection_coeff': 0.001, 'slim_time': -13, 'nucleotide': -1}]},
    time=14.0322, edge=32586)
\end{minted}
There are two parts of this record that give away the fact that this was a recurrent mutation.
First, the \verb|derived_state| is a comma-separated list of \emph{two} integers, \verb|621,622|.
These integers are the \slim IDs of the corresponding mutations.
Second, the \verb|mutation_list| element of the mutation's metadata has two entries which represent those two \slim mutations,
the first (with \slim ID 621) one occurring 1691 ticks ago and the second (with \slim ID 622)  occurring 13 ticks ago.
% This allows \slim to reconstruct these events in order
% to apply the appropriate stacking policy if this tree sequence is used as an initial state for a forward-in-time simulation.
% So, for example,
% we can infer that a mutation occurred at this site at \verb|slim_time| $-559$ producing a derived state of 193, and then another mutation
% occurred at the same site at \verb|slim_time| $-7$ producing a derived state of 194.
If another mutation occurred later at this site on a genome carrying this mutation,
it would be recorded as a separate mutation in the mutation tables,
with derived state and mutation list having three entries each.
This is why, when modifying
the selection coefficients of each mutation earlier in this section, we had to have two nested loops --
one iterated over mutations,
while the second updated each element of the mutation's associated \verb|mutation_list|.

Sharp-eyed readers will note that the ``time'' of the mutation given by the tree sequence (14.0322 generations ago) does not exactly
correspond to the \verb|slim_time| recorded in metadata ($-13$ generations in the future); in general this conversion is ``rounded and sometimes
off by one, depending on the model type''. For a detailed discussion of how time is converted between the tree sequence and the \slim
model, see the \pyslim documentation.

\subsection{Loading into \slim}

We can finally move on to the forward-in-time component of our hybrid simulation.
First, suppose we have written out the tree sequence from the previous section to file
using \verb|sts.dump("init.trees")|.
We need to ensure that everything matches
between the tree sequence and the initialization of the \slim recipe we will use to load the file.
Specifically, the model type must match what we specified in the tree sequence's metadata;
the genome length must be equal to the tree sequence's \verb|sequence_length|,
and each mutation type used in the tree sequence must be declared (above, we used \verb|m2|).
In the script we will also define a placeholder mutation type \verb|m1| for neutral mutations, to be added later.
There is no need to set up a population or individuals -- this is read in from the tree sequence.
%% PLR: no need to do this?
% but we will make a point to ``Remember'' all the individuals who are alive at the start of the simulation to facilitate downstream analysis.
\begin{lstlisting}[language=slim, style=slimstyle, breaklines=true]
initialize()
{
    initializeSLiMModelType("WF");
    initializeTreeSeq();
    initializeMutationRate(3e-10);
    initializeMutationType("m1", 0.5, "f", 0.0);
    initializeMutationType("m2", 0.5, "f", 0.001);
    initializeGenomicElementType("g1", m2, 1.0);
    initializeGenomicElement(g1, 0, L-1); // specify L, the genome length
    initializeRecombinationRate(1e-8);
}
1 late() { 
    sim.readFromPopulationFile("init.trees");
}
100 late() {
    sim.treeSeqOutput("final.trees");
}
\end{lstlisting}
This \slim code picks up the simulation where \msprime left off, applying the same mutation rate and recombination rates
for an additional 100 generations.
However, in this phase, an individual's genetic make-up (\ie the non-neutral genetic variants they carry)
will influence their fitness as the population continues to evolve.

\subsection{On the equivalence of recapitation and burn-in}

A coalescent simulation from \msprime
is statistically identical to that produced by a forwards-time simulation
(using precisely what model depends on some details).
So, doing burn-in with \msprime is (nearly) identical to running a very long burn-in period
with \slim and the same population size.
(The only caveat here has to do with differences between discrete and continuous time.)
This \slim burn-in would need to be long enough so that everything has ``coalesced''.
As discussed in \citet{haller_tree-sequence_2019}, this often takes 20 or 30 times $N_e$ generations.
So, it is tempting to use \slim's option that allows for ``checking for coalescence''
and stop the burn-in when coalescence is reached.
However, as pointed out by the \slim manual,
this is incorrect: the first time coalescence is reached is special, and has lower diversity than a typical time point.


\section{Generating genetic data}

Next, we will discuss some final steps for generating a genetic dataset from our hybrid simulation that has many of the properties of real data that is generated from
sequencing or genotyping real organisms. Whether it was generated by recapitation or by first generating initial
diversity with a coalescent simulation, the following steps are necessary for adding realistic levels of neutral diversity and for ultimately producing a
file that can be analyzed by standard methods.

\subsection{Overlaying neutral mutations}
In our two previous sections outlining the two main methods of performing a hybrid simulation, we did not bother to add neutral mutations to the tree sequence.
This is because neutral mutations do not impact the shape of the genealogy, and so adding them after the fact is equivalent to tracking them as the
simulation proceeds;
it is more efficient because it relieves \slim of the burden of tracking these irrelevant variants.
%% if you simulated neutral mutations in your SLiM phase, you'd want to be careful about adding mutations again in this phase - you'd end up with 2x rate in the SLiM portion only
In the ``Generating initial diversity'' section above, we stated that we wanted to simulate an overall mutation rate of $3 \times 10^{-8}$,
with 99\% of the resulting mutations neutral.
We already added the 1\% of non-neutral mutations, so now, we need to add neutral mutations at a rate of $0.99 \times 3 \times10^{-8}$.
We will set the mutation ``type'' to 1 so that we can easily distinguish neutral and non-neutral
mutations on this property (recall that non-neutral mutations were of type 2),
matching the preamble of the \slim script above.
The first step is to load the tree sequence output by \slim:
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
ts = tskit.load("final.trees")
next_id = pyslim.next_slim_mutation_id(ts)
mut_model = msprime.SLiMMutationModel(type=1, next_id=next_id)
vts = msprime.sim_mutations( ts, rate=0.99 * 3e-8,
        model=mut_model, keep=True)
\end{minted}
We use \pyslim's \verb|next_slim_mutation_id| to identify the \slim mutation ID for \msprime to pick up from,
which is important as all \slim mutation IDs in the tree sequence must be unique.
Additionally, we include \verb|keep=True| so that existing mutations are not discarded.

\subsection{VCF output}
The final step we demonstrate is to output the \slim-coded genotype information as a Variant Call Format (VCF) file.
Doing so requires remapping some of the information to a form that resembles real genetic data.
For example, the \slim mutation model encodes the ancestral state of every site as the empty string and the derived state
as a comma-separated list of integers (also stored as a string).
These states are meaningful for \slim but do not correspond to the nucleotides expected in a VCF.
To address this, \pyslim provides functions to convert \slim mutations to a more conventional format:
first, \verb|generate_nucleotides| adds nucleotides to \slim mutations not containing nucleotides,
and second, \verb|convert_alleles| replaces the comma-separated lists of integers in the ancestral and derived states of the tree sequence
with the corresponding nucleotides.
% Since we started with the code above, we had to do both steps;
% if in \slim we had used a nucleotide mutation model, then the first step would not have been necessary.
Following these steps, \tskit's method \verb|write_vcf| can be used to output the VCF
(and the method itself provides more options):
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
nts = pyslim.generate_nucleotides(vts)
nts = pyslim.convert_alleles(nts)
with open('nucs.vcf', 'w') as f:
    nts.write_vcf(f)
\end{minted}
This simply assigns each position a randomly chosen nucleotide,
and then assigns each mutation a nucleotide chosen randomly out of the three that are different
from the previous state (\ie from the Jukes-Cantor model).
More complex models could be implemented in python.

% % PLR: I don't think the following is necessary, or maybe even entirely accurate? Genotype information isn't "changed" really,
% % although the 0|1 sort of information that's printed out by write_vcf() might be? The complicated caveats around non-uniqueness
% % only apply if some mutations already have nucleotides and some don't, which is something we probably don't want to get into?
% If we compare the output of this process to a VCF file generated from the unconverted tree sequence, we can see that all previously empty ancestral states and
% all integer value derived states have been assigned a specific nucleotide.
% In the case of recurrent mutation, the \verb|generate_nucleotides| function aims to assign a unique
% nucleotide to each derived allele, but under certain specific circumstances
% this is no longer possible. It is important to note that the genotype information associated with each specific individual is
% sometimes changed by this operation.

The key step in both this and the next section will be to combine the results of different simulation runs.
For instance, the tree sequences produced by the simulations of branches $A$ and $B$
will share history up until their branching point;
which we need to take into account when we put these two tree sequences back together.
Since the two share some history but we want to combine the bits of history they don't share,
the operation is called ``union''.
Although this operation abstractly sounds straightforward --
``we just need to take the bits of the tree sequence that happens on the branch to $B$
and add it to the tree sequence from $A$'' --
in practice many things can go wrong.
To ensure that we can put them together smoothly,
we need to make sure that the parts of shared history recorded in each simulation agree.
This is discussed in more detail below.

\subsubsection{Coordinates in the VCF}

There is one more source of VCF-related problems: position 0.
The VCF standard says that positions must be positive.
\slim and \msprime both, by default, have genomes that begin at 0.
So it is easy to produce a VCF using the pipeline above with a variant at position 0,
and this causes problems with some downstream tools.
To deal with this \slim \textbf{adds one to all positions} on VCF output
(and then subtracts one when reading in VCFs).
On the other hand, \tskit is agnostic: it just represents coordinates and so takes no position
about where the start of the chromosome should be.
To deal with situations like this, \tskit's \verb|write_vcf| method of a tree sequence
has a \verb|position_transform| argument.
For instance, passing \verb|lambda x: np.fmax(1, np.round(x))| will move any variant at position 0 to position 1
(which may be less confusing than shifting by one).
Or, passing \verb|lambda x: x + 1| imitate \slim's default output.
If your output contains a variant at position 0, \verb|write_vcf| throws an error
(which can be disabled).


\section{Parallelizing forward-in-time simulations of multiple species}

We have thus far demonstrated how to combine backwards- and forwards-in-time simulations
in two different ways.
Now, we will discuss how to distribute the computational load of a highly complex forward-in-time simulation across multiple processes operating in parallel,
by simulating different branches of a phylogeny independently
and stitching the resulting tree sequences together.
This approach can drastically reduce overall clock time and the memory requirements of a large phylogenetic simulation.
The main challenge with this approach then becomes
determining how to stitch together multiple ARGs that represent the same time span.

The idea works because if there is no migration between species,
any two branches stemming from the same node in a given tree do not affect each other,
and thus can be simulated in parallel.
Figure~\ref{fig:phylo} shows the simple example we work with.

\begin{figure}[h!]
    \centering
     \includegraphics[width=0.33\textwidth]{code/parallelizing_multiple_species/phylo.pdf}
     \caption{
         Example phylogeny.
         Branches with the same color can be simulated in parallel if there is no migration between them.
     }
     \label{fig:phylo}
\end{figure}

\subsection{Parallel simulation of branches}

We will use the following \slim script to simulate the history of each species, represented by its own branch, in our phylogeny. Here, each species can have a different
(but fixed) population size (\verb|popsize|) and total duration (\verb|num_gen|).
Additionally, we will simulate deleterious mutations accumulating across the entire genome at a fixed rate.
%
\inputminted[breaklines, breakautoindent=true, breakanywhere=true, fontsize=\small, linenos, bgcolor=gray!10]{slim}{code/parallelizing_multiple_species/simulate_branch.slim}
%
Notice that, in addition to \verb|popsize|, \verb|popname| and \verb|num_gen|, the variables \verb|infile| and \verb|outfile| are left undefined in this \slim script.
This allows the relationship between branches, and the
resulting tree sequences, to be explicitly defined. As a result, this single \slim model can represent every species simply by passing the appropriate values of \verb|infile| and \verb|outfile|.
When initializing a \slim simulation using an existing tree sequence, the starting tick is updated
based on the time specified in the tree sequence's metadata, as seen above.
Therefore, we define the ending tick of the simulation as the start time plus the \verb|num_gens| argument.

% % PLR: I don't think we use this table?
% We can do this by recoding the phylogeny depicted in Figure~\ref{fig:phylo} as a table:
% \begin{table}[h]
%   \centering
%   \caption{Parameters of the phylogeny that will be simulated.}
%   \label{tab:phylo}
%     \begin{tabular}{llll}
%       \bfseries Child & \bfseries Parent & \bfseries Population size & \bfseries Edge length \\
%       \hline
%       \csvreader[head to column names]{code/parallelizing_multiple_specie/phylo.csv}{}%
%         {\child & \parent & \popsize & \edgelen\\}
%     \end{tabular}
% \end{table}
% For each branch, the presence or absence of \verb|infile| tells \slim whether a previous branch exists or not. For the \verb|root| branch of our phylogeny, there is no \verb|parent|; this is the branch
% that is ancestral to all other branches. For all other branches, \slim will read in the \verb|parent| tree sequence and use the living individuals to create a new population, adjusting the
% final population size based on the corresponding value in the table. 

%%%% not sure that remembering is actually necessary in this case
At the end of the simulation, we call \verb|sim.treeSeqRememberIndividuals| right before saving the resulting tree sequence.
This is necessary to ensure that the individuals in the final generation are never dropped from any of the future runs that are started from this simulation's output,
as they will be needed later to merge the tree sequences generated from parallel runs back together.
%%%%

To actually run our parallelized simulation, we could use workflow management software, such as Make or Snakemake, or a custom script -- see the \pyslim
\href{https://tskit.dev/pyslim/docs/latest/vignette_parallel_phylo.html}{documentation} for details on different implementations. Here, we will use the simple Make script below to pass
the appropriate parameters to our generic \verb|simulate_branch.slim| script.
%
\inputminted[breaklines,fontsize=\small, breakanywhere=true, breakautoindent=true, linenos, bgcolor=gray!10]{basemake}{code/parallelizing_multiple_species/parallel_sims.make}
%
This script essentially recodes our original phylogeny through a list of `rules' that define each parent-child relationship.
For example, the files `A.trees' and `B.trees' both depend on the internal node `I.trees',
which in turn depends on the result of simulating the ultimate ancestral branch `root.trees'.
Each rule in the Makefile also specifies how to generate the output given the required input through a single line of \slim code.

We can then run these simulations in parallel by executing the following bash code,
in which the -j argument specifies the maximum number of simulations to run simultaneously:
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{bash}
make -f sims.make -j 3
\end{minted}

\subsection{Putting it back together: unioning the tree sequences}

We now need to stitch the resulting tree sequences back together.
Remember, each of the tree sequences representing species `A', `B', and `C'
are distinct, but overlap significantly as a result of their shared evolutionary history.
To join them together, we need to specify which bits are shared and which are not.
This can be accomplished for pairs of tree sequences using the \verb|union| operation from \tskit,
which simply copies the unique parts of one of the tree sequence onto the other.
Figure~\ref{fig:union} illustrates how this works.

\begin{figure}[h!]
    \centering
     \includegraphics[width=\textwidth]{figures/union.pdf}
     \caption{
         Species A and B share the same ancestral history, but after the split they are simulated independently.
         Note how the history above the split (delimited by the individuals which are remembered and persistent across tree sequences, highlighted in green, blue and orange) is identical,
         thanks to the call to treeSeqRememberIndividuals at the end of each branch.
     \tskit's \texttt{union} operation will merge these tree sequences given a mapping that communicates which nodes in the two tree sequences are the same.
     In this example, union would add to A any new history found in B;
     these new nodes and relationships are shown in light red in the result.
     \label{fig:union}
     }
\end{figure}

The key to correctly combining a given pair of tree sequences is to identify which parts of each are shared between the two.
There are potentially many ways to do this;
\verb|union| works by identifying nodes,
and so requires a `map' that matches shared nodes across the two tree sequences
(and unmatched nodes are new).
Using this map, \verb|union| (a) checks that any properties of shared nodes and relationships between them are identical, and
(b) appends any new nodes and relationships found in the second tree sequence to the first one.
Luckily, \slim stores a value called \verb|slim_id| in the metadata of each node that it produces,
which we can use to identify the shared nodes.
However, a matching \verb|slim_id| is not sufficient to identify a positive match,
because although \verb|slim_id| values are unique within a given \slim simulation,
the same IDs will be used in different (parallel) simulations.
When \slim loads a tree sequence in order to continue a simulation,
it will start assigning \verb|slim_id| values to new nodes using the last \verb|slim_id| value
present in the ancestral tree sequence as a starting point.
So, when more than one simulation is initiated with the same
ancestral tree sequence and the resulting tree sequences are merged back together, it is likely for the same \verb|slim_id| to be used to refer to different nodes.
However, we can use node \emph{time} to resolve the issue:
referring to Figure~\ref{fig:union}, if two nodes that were born at or before the split time between `A' and `B'
have the same \verb|slim_id|, then they must represent the same ancestral genome (and so must have exactly the same time);
while if they were born after the split time, they represent different ancestral genomes.
The following function constructs a ``node map'' that identifies the nodes shared by two tree sequences, \verb|other| and \verb|ts|,
by identifying pairs of nodes that arose before \verb|split_time| and have the same \verb|slim_id|.
The output is an array with one value for each node in \verb|other|,
whose \verb|j|th entry is the ID of the matching node in \verb|ts| if the node is shared,
and is \verb|-1| otherwise.
This code could be made easier to read by iterating over nodes,
but the following numpy-based version is much faster:
%    """
%    Given SLiM tree sequences `other` and `ts`, builds a numpy array with length
%    `other.num_nodes` in which the indexes represent the node id in `other` and the
%    entries represent the equivalent node id in `ts`. If a node in `other` has no
%    equivalent in `ts`, then the entry takes the value `tskit.NULL` (-1). The
%    matching is done by comparing the IDs assigned by SLiM which are kept in
%    node metadata. This matching of SLiM IDs is *only* done for nodes with time
%    older than the specified `split_time`.
%    """
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
def match_nodes(other, ts, split_time):
    node_mapping = np.full(other.num_nodes, -1, dtype='int')
    ts_ids = np.array([n.metadata["slim_id"] for n in ts.nodes()])
    other_ids = np.array([n.metadata["slim_id"] for n in other.nodes()])
    alive_before_split1 = (other.tables.nodes.time >= split_time)
    shared_id = np.isin(other_ids, ts_ids)
    both = np.logical_and(alive_before_split1, shared_id)
    sorted_ids = np.argsort(ts_ids)
    matches = np.searchsorted(
        ts_ids,
        other_ids[both],
        side='left',
        sorter=sorted_ids
    )
    node_mapping[both] = sorted_ids[matches]
    return node_mapping
\end{minted}
This node map can then be used with \verb|ts.union| to combine our tree sequences pairwise.
A general-purpose recursive strategy to do this is provided in the \pyslim documentation,
but the problem is easy in this simple example:
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
A, B, C = (tskit.load(f"{x}.trees") for x in ['A', 'B', 'C'])
nm = match_nodes(B, A, split_time=50)
AB = A.union(B, nm)
nm = match_nodes(C, AB, split_time=200)
ABC = AB.union(C, nm)
\end{minted}
% 
% The following recursive function through the data frame containing the phylogeny and returns a dictionary
% describing a series of merging steps from tip to root.
% For a simple example such as the one we describe here, this could be done easily by hand; however, the following function
% is more flexible and will work even for complex cases.
% \begin{minted}[fontsize=\small, linenos, bgcolor=gray!10]{python}
% merged = {
%     row.child : {
%         "ts": tskit.load(row.outfile),
%         "depth": row.edgelen,
%         "children": [row.child]
%     }
%     for i, row in df[df.is_leaf].iterrows()
% }
% 
% def union_children(parent, df, merged):
%     print(f"Going in: {parent}")
%     child_rows = df[df.parent == parent]
%     assert (len(child_rows) == 2) or (len(childs) == 0)
%     if len(child_rows) == 2:
%         children = [row.child for _, row in child_rows.iterrows()]
%         for child in children:
%             if child not in merged:
%                 union_children(child, df, merged)
%         split_time = merged[children[0]]["depth"]
%         assert split_time == merged[children[1]]["depth"] # ultrametric
%         print(f'Unioning: {children}, Split time: {split_time}')
%         ts0 = merged[children[0]]["ts"]
%         ts1 = merged[children[1]]["ts"]
%         node_map = match_nodes(ts1, ts0, split_time)
%         tsu = ts0.union(ts1, node_map)
%         # the time from tip to start of simulation is split_time plus the
%         # length of the edge
%         parent_edgelength = df[df.child==parent].edgelen.item()
%         merged[parent] = {
%             "ts": tsu,
%             "depth": split_time + parent_edgelength,
%             "children": merged[children[0]]["children"] + merged[children[1]]["children"]
%         }
% 
% union_children("root", df, merged)
% # union of all three species tree sequences is in the root.
% tsu = merged["root"]["ts"]
% pops = merged["root"]["children"]
% \end{minted}
% 
The result of executing this code is a single tree sequence,
\verb|ABC|,
that fully represents the genealogy of the sampled individuals from all three extant species in our phylogeny (Figure~\ref{fig:phylo}).
Because each branch of the tree was modeled as a distinct population and \slim, it is straightforward to identify which nodes and individuals belong
to which branch on the phylogeny throughout time.
After potentially recapitating and adding neutral mutations, we could analyze this tree sequence
like any other to answer a variety of questions related to the evolutionary history and genetic ancestry of these species.
% For example, by running multiple replicates of this
% simulation, we could achieve a reasonable expectation of the rate of incomplete lineage sorting under these specific demographic parameters.

When adapting this code for your own use, it is common to run into a situation
where you get an error saying that ``shared portions of the tree sequences are not equal''.
Although it is possible to, it is important to \emph{not} disable this check:
almost certainly, this error is alerting you to a problem,
and proceeding with the union would produce incorrect results.

The major advantage of running simulations in parallel is that it expands the scope for complexity and size of feasible models.
We can simulate many more species, or much larger
populations within those species, if we can split the computational burden in this way.
For example, \citet{rodrigues_shared_2024} used this parallelized approach to conduct
whole-chromosome simulations of the entire history of great apes spanning over 10 million years.
In this case, some individual species simulations used over 100Gb of memory,
and so without parallelization, simulating great apes species history in a single process would have been effectively impossible given the current limitations on computational resources.

\section{Meta-population dynamics with simulation networks}

Finally, we consider a more complex scenario that requires more advanced manipulations of the tree sequence:
simulation of the within-host dynamics of a pathogen,
where individual hosts are simulated in parallel using the same basic \slim script.
This is therefore similar to the previous example, but more complex for two reasons:
1) we don't want to retain the entire population at branch points, for efficiency reasons; and
2) we will allow for reticulations in the ``phylogeny'',
which occur when a host individual is infected from more than one source.
% Accommodating these scenarios requires some tweaks to the previous modeling
% framework such that we can retain all the information necessary to identify shared sections in all possible pairs of tree sequences.
% We demonstrate how to accomplish this task
% by using pathogen evolution as an example.


% \begin{figure}[h!]
%     \centering
%      \includegraphics[width=\textwidth]{figures/DAG_no_reticulation.pdf}
%      \caption{
%         Nodes in this figure represent individual host infections, while the arrows represent the direction in which pathogens are transmitted from one to the next. 
%      \label{fig:DAG_no_reticulation}
%      }
%     \end{figure}

\begin{figure}[h!]
    \centering
     \includegraphics[width=\textwidth]{figures/DAG_w_reticulation.pdf}
     \caption{
        Nodes in this figure represent individual host infections, while the arrows represent the direction in which pathogens are transmitted from one to the next. Here, red arrows represent cases of reticulation in the transmission graph, where a host infection is founded by pathogens from two distinct source infections.
     \label{fig:DAG_w_reticulation}
     }
\end{figure}

We can model a pathogen infecting a host species as a large meta-population, where each infected host constitutes a distinct pathogen deme.
Similar to our previous section, we can represent the relationship between individual hosts with a phylogeny-like branching structure, as in Figure~\ref{fig:DAG_w_reticulation}.
In this figure, nodes represent pathogen subpopulations within individual hosts and transmission events from one host to another are represented by edges.
% Although this model operates on a much shorter time scale than the prior example,
% \ie weeks-months versus thousands-millions of years, this underlying structure enables the use of parallelization
% to significantly reduce the speed and computational burden of this simulation.

Just as in the prior vignette, the backbone of this model is a flexible \slim script that can accept a specific tree sequence as a starting point in addition to other
parameter values.
This script simulates the logistic growth of pathogen individuals within a host,
as well as a bottleneck of a few pathogens to be transmitted to each subsequent host.
These dynamics will play out repeatedly as we model the pathogen
spreading through the host population.

Three major differences to the previous model are that branching (\ie transmission events) can occur at various times during a given host infection,
that one simulation can begin with the results of more than one previous simulation,
and that we use a non-Wright-Fisher model with overlapping generations.
Based on the previous approach,
a first try at this might be to save the tree sequence at the times of each new infection.
However, this fails:
previously, we could assume when combining two simulations
(see Figure~\ref{fig:union}) that all shared individuals had identical lives,
but with overlapping generations more care must be taken.
If two simulations begin with the same tree sequence for an initial state,
then the ``same'' individuals could live parallel and contradictory lives along the two branches of the simulation.
Furthermore, we would like to save only those few individuals who start each new infection,
rather than the entire population.
% We could simply save the state of the population at the these different time points and have the \slim run representing the next host use this
% as its initial state. However, without significant modifications, this would result in the loss of crucial information during simplification, making it impossible
% to merge the resulting tree sequences at the end of the simulation. The reason for this is that earlier transmission events in the host infection, and
% the associated tree sequences, cannot `know' what the future state of the population will be when later transmission events occur. As a result, the nodes associated with
% individuals that will be transmitted at a later time point, and/or their ancestors, might be simplified out of earlier-transmitted tree sequences. Of course, if we turned off
% simplification, we would never lose any genealogical information and could merge all resulting tree sequences without issue. Unfortunately, this is very impractical in most cases,
% as it would necessitate storing massive amounts of genealogical data, ultimately running up against memory and storage limits within just a few simulated generations.
So, we will store only the information needed for piecing the full genealogy back together, allowing \slim to simplify out the rest to maintain efficiency.
Each host simulation produces a single output tree sequence
that contains all the samples required to represent all downstream transmission events.
Then, we make use of advanced operations to use this single tree sequence
to start several different downstream simulations.

The basic workflow for a within-host \slim simulation is as follows. The infection starts by loading an input tree sequence, if specified,
as well as additional information that specifies which hosts the current infection will be transmitted to (\verb|OUTPUT_HOST_IDS|),
when these transmission events will happen, relative to the start of the simulation, (\verb|TRANSMISSION_DAYS|),
and how many pathogen individuals will be transmitted (\verb|NUM_SAMPLES|).
The simulation proceeds with the pathogen reproducing according
to some rules; in our case, we parametrize this process by setting an overall growth rate (\verb|POP_GROWTH_RATE|)
and a carrying capacity for pathogens within the host (\verb|K|).

\begin{lstlisting}[language=slim, style=slimstyle, breaklines=true]
initialize() {
  initializeSLiMModelType("nonWF");
  initializeSLiMOptions(keepPedigrees = T);
  initializeTreeSeq();
  defineConstant("HOST_ID", "00");  // the current host ID
  defineConstant("INFILE", "");  // optional file to read in
  defineConstant("TRANSMISSION_DAYS", c(20));
  defineConstant("OUTPUT_HOST_IDS", c("01")); // IDs to transmit to
  defineConstant("N_FOUNDERS", 20);  // number transmitted
  defineConstant("POP_GROWTH_RATE", 1.0);
  defineConstant("K", 1e5);
  
  initializeChromosome(1, GENOME_LENGTH, "H");
  initializeRecombinationRate(0);
  initializeMutationRate(0);
  initializeMutationType("m0", 0, "f", 0);
  initializeGenomicElementType("g1", m0, 1);
  initializeGenomicElement(g1, 0, 0);

  // used to pass information along with the tree sequence
  defineConstant("PARAMS", Dictionary());
}
\end{lstlisting}

If there is no input file given,
we begin by creating a new subpopulation in \slim whose ID is equal to the current host ID.
If there is an input file, this subpopulation is created upon loading that file.
This step also creates dictionaries for founder pathogen IDs and infection start times (\ie \textit{founding times})
that will be stored later in metadata, for access within \slim as well as \tskit.
If there is a tree sequence file given,
we reload the simulation state from the file,
as well as additional \emph{metadata} from the tree sequence file.
In the metadata, we've stored the IDs of the individuals who are to be the founders,
so we move these to a newly created subpopulation.
Finally, this code
calculates the \textit{absolute transmission times} (the day of the overall simulation) by adding the start time of the current simulation to transmission days supplied.
\begin{lstlisting}[language=slim, style=slimstyle, breaklines=true]
// Pathogens infect host
1 late() {
   // start seed simulation or load an input file
   pop_id = asInteger(HOST_ID);
   if (INFILE == "") {
      sim.addSubpop(pop_id, N_FOUNDERS);
      PARAMS.setValue("FOUNDING_TIME", Dictionary(HOST_ID, sim.cycle));
   } else {
      sim.readFromPopulationFile(INFILE);
      // pass on information kept in metadata
      metadata = treeSeqMetadata(INFILE);
      PARAMS.setValue("FOUNDING_TIME", metadata.getValue("FOUNDING_TIME"));
   }
   // track simulation start day
   defineConstant("SIM_START", sim.cycle);
}
\end{lstlisting}

We then allow this population to evolve.
Each individual produces a random number of clonal offspring.
Then, every individual's probability of survival
(their \verb|fitnessScaling|) is set depending on the overall population size;
when the population exceeds the carrying capacity,
probability of survival is reduced to bring their numbers back down.
\begin{lstlisting}[language=slim, style=slimstyle, breaklines=true]
// Pathogens replicate within the host
reproduction() {
  num_offspring = rpois(1, POP_GROWTH_RATE);
  subpop.addCloned(individual, count=num_offspring);
}

2: early() {
  sim.subpopulations.fitnessScaling = pmin(0.9, K / sim.subpopulations.individualCount);
}
\end{lstlisting}

When the simulation reaches one of the designated \textit{transmission days},
an additional callback is executed that transmits some individuals to a subsequent host.
To do this, the code first identifies which host IDs should be transmitted to,
and then randomly chooses which individuals will be the ``founders'' for these new infections.
Each founder is then moved to a new subpopulation whose ID matches the ID of the new host ID,
remembered, and killed.
(Recall that ``remembering'' an individual means that they remain in the tree sequence forever.)
As we will see, these individuals are only dead temporarily;
they will be resurrected in order to
continue the simulation as the founders of the next host infection.
 A final piece of bookkeeping is to store information about this event in metadata:
the \verb|FOUNDING_TIME| is a dictionary that simply records when this transmission event for each host happens.
This information (along with everything else in \verb|PARAMS|)
is attached to the output tree sequence as top-level metadata.
This property
of tree sequences, which is accessible in both \slim and python, is extremely useful because it can store arbitrary bits of information that we might want later.
In our case,
we will use \verb|FOUNDING_TIME| to determine how to properly resurrect these founding individuals.
\begin{lstlisting}[language=slim, style=slimstyle, breaklines=true]
// Pathogens are transmitted to next host
unique(ABS_TRANSMISSION_DAYS) late() {
  // figure out which hosts to transmit to
  which_hosts = which(ABS_TRANSMISSION_DAYS == community.tick);
  hosts_to_infect = OUTPUT_HOST_IDS[which_hosts];
  // determine how many pathogens are needed to infect all hosts
  N_pathogens = rep(N_FOUNDERS, count = length(hosts_to_infect));
  // sample individuals to transmit
  active_pop = sim.subpopulations[sim.subpopulations.id == asInteger(HOST_ID)];
  transmitted_inds = active_pop.sampleIndividuals(size=sum(N_pathogens), replace=F);
  founding_time = PARAMS.getValue("FOUNDING_TIME");
  for (host in hosts_to_infect, count in N_pathogens, range_end in cumSum(N_pathogens)) {
    sampled_inds = transmitted_inds[(range_end-count):(range_end-1)];
    founding_time.setValue(host, sim.cycle);
    new_pop = sim.addSubpop(asInteger(host), 0);
    new_pop.takeMigrants(sampled_inds);
  }
  // permanently remember these individuals through subsequent tree sequences;
  // this must happen after they are moved to the new population above
  sim.treeSeqRememberIndividuals(transmitted_inds);
  sim.killIndividuals(transmitted_inds);
}
\end{lstlisting}

This simulation runs as long as necessary to complete all the specified transmission events,
and then ends by writing out a single output tree sequence.
In this tree sequence, all
individuals that were transmitted at any point in the simulation will be \textit{remembered} as samples, but will be dead. Additionally, we kill all remaining individuals in the host population
just before writing the output. If we did not do this, thousands of individuals alive at the final tick of the simulation would also be marked as samples and their full genealogical history
would be stored in the tree sequence. Because we only care about the relatively few individuals that will go on to found new infections, we can save significant time and memory
by getting rid of everyone else, too.
\begin{lstlisting}[language=slim, style=slimstyle, breaklines=true]
max(ABS_TRANSMISSION_DAYS) late() {
	sim.killIndividuals(sim.subpopulations.individuals);
	sim.treeSeqOutput("sim_" + HOST_ID + ".trees", metadata=PARAMS);
	sim.simulationFinished();
}
\end{lstlisting}

Now we have a tree sequence with no living individuals at all, which will not be of much use if we were to load it back into \slim directly. We therefore need to do some processing
with \tskit before we can initiate the next set of infections, which is accomplished with a python script.
This script is passed a tree sequence and a host ID,
and then retrieves the starting time of that respective infection from top-level metadata (from \verb|FOUNDING_TIME|).
The script then uses the \verb|set_slim_state| function in pyslim to rewind
the tree sequence's time, and also to resurrect any individuals that were still alive at that time.
This function does two things: it resets the time as recorded by \slim in the tree sequence,
and labels a given set of individuals as being alive.
This results in a curious thing: the tree sequence can contain information about the ``future''.
Of course, \slim only pays attention to those individuals that are marked as being alive,
so this is harmless.
The argument to \verb|set_slim_state| is in \tskit time ago,
while the value we stored in metadata was a \slim tick,
so to convert we subtract the stored tick from the current tick,
which we obtain from top-level metadata.
This step is done for every host that the current infection transmits to, producing
a distinct version of the output tree sequence for each one.
\begin{minted}[fontsize=\small, linenos, bgcolor=gray!10, breaklines]{python}
# input: ts, host_id
tick = ts.metadata['SLiM']['tick']
new_tick = ts.metadata['SLiM']['user_metadata']['FOUNDING_TIME'][0][host_id][0]
founders = [ind.id for ind in ts.individuals() if ind.metadata['subpopulation'] == host_id]
rts = pyslim.set_slim_state(ts, time=tick - new_tick, individuals=founders)
\end{minted}
Then, \verb|rts| is written out, to start a new simulation.
The code above is somewhat simplified for clarity:
in practice we also remove individuals with duplicate pedigree IDs,
which can happen when the input tree sequence was produced by merging
the output from two distinct simulations.

For hosts who are infected by founders from more than one other infection,
before doing the previous step we need to merge the tree sequences that are output by
the upstream simulations.
For instance, if host 4 is infected by pathogens from both hosts 1 and 2,
then the tree sequences output from both hosts 1 and 2
have founders we need to start the simulation for host 4.
So, we need to merge these (using \verb|union|).
We will also want to merge the multiple tree sequences produced by all
terminal simulations into one as well.
In our previous example, we used the split time between two branches
to disambiguate distinct nodes that might happen to share a \verb|slim_id|.
That won't work here because some of the shared nodes can be more recent than the split time,
thanks to the resetting done by \verb|set_slim_state|.
As previously noted, we use the current host ID as the subpopulation ID within \slim.
Since host IDs are unique,
we can use a combination of \verb|slim_id| and \verb|population| to
definitively match them across pairs of tree sequences,
and to generate the node map required by \verb|tskit.union|.
Tree sequence merging can then be achieved in the same way as outlined
in our previous vignette. %%See full example on github? appendix?

However, there are a few additional steps.
These are required basically because we need to help \verb|union|
identify what is ``the same'' between tree sequences and what is not.
So, the python script that merges two tree sequences:
(1) Shifts the node and mutation times in each input so that time matches,
by adding to the "time ago" of each the difference between their \slim tick and the largest \slim tick.
(2) Merges the population tables so that any populations described in the second
are also described in the first.
(3) Updates individual metadata and flags for any individuals contained in both,
identified by unique combinations of birth \verb|population|, \verb|pedigree_id|,
so that these agree between the two tree sequences for shared individuals.
This is necessary for rare cases in which, for instance, a founder of one host infection
is then passed on to found yet another infection in another host,
in which case the age and subpopulation recorded in metadata in the two tree sequences
will not match (and we want to use the later one).
(4) Constructs a node mapping from the second to the first, by identifying those
nodes sharing unique (birth \verb|population|, \verb|slim_id|) pairs.
(5) Unions the two with this mapping.
(6) Copies missing keys from \verb|FOUNDING_TIME| in the second's metadata to the union.

Similar to the previous example, we can run our simulation in parallel using a job scheduler like Make. %See full example on github? appendix?
The framework we outline here makes it possible to model the evolution of very large and complex pathogen meta-populations in order to understand how both among-host
and within-host factors impact these processes. 
For example, we can use our model to develop expectations for how pathogens evolve under variable selection pressures.
Imagine a life history trade-off between replication and transmissibility, so that one allele at a particular locus allows the
individual carrying it to reproduce at a faster rate while the alternate allele increases an individual's likelihood of being transmitted to a new host.
Similar trade-offs have been observed in influenza, HIV, and COVID-19 \citep{liang2023pathogenicity, arien2005replicative, zhu2022ancestral},
but would be challenging to model realistically without parallelization. 
%Parallelizing forward-in-time models represents a powerful approach to increasing the complexity and realism of evolutionary models, but introduces some additional challenges. Luckily, there now exists a coherent software ecosystem, which includes \slim, \tskit, and \pyslim, that allows users to overcome these challenges in order to leverage the full
%power of the ARG.


%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}

Moving from simulation of genotype data to full ARGs presents many opportunities for evolutionary genomic inference.
ARGs can store a great deal more information about a population's evolutionary history,
while making simulation more efficient \citep{kelleher_efficient_2018}.
Furthermore, as we discuss here, information can also be passed between different simulations via the ARG,
which enables hybrid simulations that combine both forward- and backward-in-time components as well as parallel simulations.
In this chapter, we have sought to introduce readers to these methods' potential to expand the scope of evolutionary simulation.
Additionally, we have provided practical vignettes that use \pyslim,
a software package that provides functions to make model interoperability between \slim and \tskit more seamless.

% Time units
In this paper, we have opted to cover opportunities and strategies more than technical detail,
and so for some technical aspects, advanced users will need to consult the documentation.
One important aspect is \emph{time units}:
we alluded to the fact that time units in \slim and \tskit differ in direction,
and that exact conversion between them can be difficult:
it depends on the stage in the \slim model.
More importantly, for non-Wright-Fisher models in \slim, a single tick may not necessarily equal one generation,
so recombination or mutation rates may need to be adjusted.
The topic is covered in more detail in the \pyslim documentation.

An overarching theme here, and for evolutionary simulations more generally, is the trade-off between realism and efficiency.
Forward-in-time simulations can be fashioned to more naturally match real population dynamics,
but this generally comes at the cost of speed. On the other hand, coalescent simulations make many assumptions, many of which
are unrealistic, in exchange for faster runtimes.
The same trade-off occurs when considering rescaling \citep{cury_simulation_2022,dabi_population_2025}.
In this paper, we describe how users can begin to achieve the best of both worlds,
outlining several examples that leverage hybrid approaches and parallelization to model scenarios that would otherwise be
computationally intractable.

While approximations are always necessary in modeling, advances in simulation and ARG software have gone a long way to increase realism.
For example, we discuss how we
can use a coalescent phase to reduce the burden of simulating a burn-in period.
As a result, ancient events occur under a much less realistic model, but this may be acceptable in certain situations.
As with all cases where the validity of a particular approximation may be questionable, a good strategy is to adjust its parameters
(\eg the duration of the forward-in-time phase prior to recapitation) to see if important conclusions are affected.



%% THE END :)


%%%%%%%%%%%%%%%%%%%%%%%%%
%\section*{Author contributions}


\bibliographystyle{plainnat}
\bibliography{references.bib}

%%%%%%%%%%%%%%
\newpage
\appendix

\end{document}
